#!/usr/bin/env ruby

STATUS_MSG_REGX = /[ ]*([^ ]+)[ ]+(.+)/
COMMIT_REGX = /([0-9a-z]+) .*/
NEW_FILE = "NEW_FILES"

@add_options =  ARGV.length > 0 ? ARGV.first : ''
@commit_options = ARGV.length > 1 ? ARGV[1] : ''

def get_commit_sha(oneline_commit)
  COMMIT_REGX.match(oneline_commit)[1]
end

def make_status_entry(status_msg)
  match = STATUS_MSG_REGX.match(status_msg)
  { type: match[1], file: match[2] }
end

def add_command(file, modified_in_multiple_commits = false, is_deleted = false)
  if modified_in_multiple_commits
    puts "\# WARNING: #{file} is modified in multiple commits"
  end

  dash_p = modified_in_multiple_commits ? "-p" : ''
  "git add #{dash_p} #{@add_options} #{file} &&"
end

def commit_command(commit_msg)
  unless commit_msg.eql? NEW_FILE
    "git commit --fixup=#{get_commit_sha(commit_msg)} #{@commit_options}"
  else
    ## The user will be prompted for a commit message
    "git commit #{@commit_options}"
  end
end

def display_commit(commit)
  if commit.eql? ""
    "\# COMMIT: --NEW FILES--"
  else
    "\# COMMIT: #{commit}"
  end
end

FIX_WHITESPACE_COMMAND = "\# git-fix-whitespace --cached &&"
SCRIPT_HEADER = '#!/bin/bash'

files_per_commit = {}
commits_per_file = {}

git_status_result = `git status --porcelain`

status_messages = git_status_result.lines.collect { |line| make_status_entry(line) }
status_messages.each do |entry|
  file_commit_msg = `git-file-commit "#{entry[:file]}"`
  commits = file_commit_msg.split "\n"
  commits.each do | commit |
    files_per_commit[commit] = [] if files_per_commit[commit].nil?
    files_per_commit[commit] << entry[:file]

    commits_per_file[entry[:file]] = [] if commits_per_file[entry[:file]].nil?
    commits_per_file[entry[:file]] << commit
  end

  if commits.empty?
    files_per_commit[NEW_FILE] = [] if files_per_commit[NEW_FILE].nil?
    files_per_commit[NEW_FILE] << entry[:file]
  end
end

files_in_multiple_commits = commits_per_file.reject { |file, commits| commits.count < 2 }

puts SCRIPT_HEADER
files_per_commit.each do |commit, files|
  puts display_commit(commit)

  files.each do |file|
    puts add_command(file, files_in_multiple_commits.has_key?(file))
  end

  puts FIX_WHITESPACE_COMMAND
  puts commit_command(commit)
  puts
end

unless files_in_multiple_commits.empty?
  puts '## '
  puts '## FILES MODIFIED IN SEVERAL COMMITS'
  puts '## '
  puts
  files_in_multiple_commits.each do |file, commits|
    puts "\#\# FILE: #{file}"
    commits.each { |commit| puts "\#\# #{commit}" }
    puts
  end
end
